\title {Nitro Autotuning System Tutorial}
\author{
  Saurav Muralidharan \\
  School of Computing, University of Utah
}
\date{\today}

\documentclass[12pt]{article}
\usepackage{hyperref}
\usepackage{listings}

\begin{document}
\maketitle

\section{Introduction}
Nitro is an automatic performance tuning system for C/C++ applications.
It dynamically selects the optimal algorithmic variant to execute based
on characteristics of the underlying architecture, input data set, current system load etc.

This article provides a brief tutorial on how to use the Nitro system to
achieve optimal performance in an existing C/C++ application.

\section{Installation and Setup}
Nitro can be obtained from GitHub \url{http://github.com/54ur4v/nitro}. Before
using it, however, the following software packages must be present:

\begin{itemize}
  \item \textsl{Intel TBB} - For Parallel/Asynchronous Feature Evaluation
  \item \textsl{libSVM} - Support Vector Machine Classification Library used by Nitro
\end{itemize}

Nitro's C++ component is header-only and thus requires no installation per se. Just
make sure \texttt{NITRO\_ROOT/include} is in the include path when the 
target application is compiled.

\section{General System Architecture}
Nitro consists of two parts:

\begin{itemize}
  \item A Header-Only C++ Template Library
  \item A Python-based Autotuning Interface
\end{itemize}

An existing application can be integrated with Nitro by (1) specifying code variants,
features and constraints \textsl{within} the application code using Nitro's
C++ library, (2) building a customized autotuner for the application using
Nitro's Python interface, and (3) specifying training data and (optionally)
testing data.

The Python interface allows users to customize various aspects of the tuning
process such as enabling/disabling parallel feature evaluation, toggling
constraints, specifying which classifier to use, classifier properties etc.

\subsection{Tuning Process}
Given a set of code/algorithmic variants (hereafter referred to as code variants), and a
set of features associated with each, Nitro selects the optimal (w.r.t some
metric such as performance) variant for the given input and architecture. To accomplish
this, Nitro builds a \textsl{classification model} from user-provided \textsl{training data}.
This classification model is then used to predict the code variant to execute.

Each feature describes a characteristic of the execution environment, such as input
data set, underlying architecture, or current system load.

\section{Tuning Applications Using Nitro}

Let's try and tune a simple application using Nitro. We'll be using the
example application in \texttt{NITRO\_ROOT/examples/simple\_test}.

\subsection{Setting up the Context}
Before specifying variants and features in the target C++ application,
an object of type \texttt{nitro::context} must first be created. This object
sets up initial state and manages the coordination among the various
code variants executing within the application.


\subsection{Specifying Variants}

\subsubsection{Creating the \texttt{code\_variant} object}
Code variants are represented by the \texttt{nitro::code\_variant} class.
It takes in three template parameters:

\begin{itemize}
  \item \textbf{Tuning Policy}: For a code variant named \texttt{variantX}, a class of the
  same name is generated automatically in the \texttt{nitro::tuning\_policies} namespace in
  \texttt{nitro\_config.h}. The class is generated in accordance with what's specified in the
  \texttt{tune.py} script (described in Section~\ref{sec:tunepy}).

  \item \textbf{Argument Type Tuple}: The types of the arguments of the variant must be
  wrapped in a \texttt{thrust::tuple} type and specified here. For example, if the variant
  takes argument types \texttt{(float*, float*)}, then \texttt{thrust::tuple<float*, float*>}
  must be specified.

  \item \textbf{Device}: This can be either \texttt{nitro::sm} or \texttt{nitro::x86}, corresponding
  to a variant executing on a GPU and X86 CPU respectively.
\end{itemize}

Thus, an example instantiation of the \texttt{code\_variant} object would be:

\begin{verbatim}
using namespace nitro;

typedef thrust::tuple<float*, float*> ArgTuple;
code_variant<tuning_policies::test_variant,
             ArgTuple, sm> v(cx, "test_variant");
\end{verbatim}

This creates an object \texttt{v} of type \texttt{nitro::code\_variant}
that uses the tuning policy specified in \texttt{nitro::tuning\_policies::test\_variant},
takes in argument types \texttt{float*} and \texttt{float*}, and runs on a GPU.

Note that the string specified as the second argument to the constructor
must exactly match the name of the variant specified in the \texttt{tune.py} script.

\subsubsection{Defining Code Variants}
A code variant in Nitro can take any types of arguments but must return a real (double)
value representing the performance of the variant on the given input. There are two
ways in which a variant can be defined:

\begin{itemize}
\item \textbf{Create a Functor}: The functor must derive from \texttt{nitro::variant\_type<T1, T2, ...>}
where each $T_i$ is an argument type of the variant. Further, it must override the function call
operator taking the correct argument types and returning a double. In our running example, this would
be \texttt{double operator()(float*, float*) \{ ... \}}.

\item \textbf{Wrap Function Pointer}: In case the variant is defined as a function that
accepts the relevant argument types and returns a double, then Nitro provides a function pointer wrapper
class \texttt{wrap\_variant} that can create the correct functor type. For our example, this would
be (assuming \texttt{variant1} is one of the variants defined as a function):
\texttt{nitro::wrap\_variant<float*, float*> \_variant1(variant1);}.
\end{itemize}

\subsubsection{Adding Variants}
Variants defined using the notation explained in the previous sub-section can be added to
a \texttt{code\_variant} object by using the \texttt{add\_variant} function. It accepts
a pointer to the function object representing the concerned variant and adds it to the internal
list of variants maintained by the \texttt{code\_variant} object.

\subsubsection{Executing the Variant}
Execution of the variant is accomplished by simply calling the \texttt{code\_variant} object's
function call operator with the required input arguments. Depending on the tuning context, Nitro
automatically selects the correct internal variant to execute.

\subsection{Specifying Features}

Features are characteristics of the execution context of the application. This includes
features of the input data set, underlying architecture, current system load etc.

\subsubsection{Specifying Input Features}
Input features can be specified in a way similar to variants: using either a functor, or
using the \texttt{wrap\_feature} metafunction. They take in the exact same input as the
variant will, and must return a real value (double) representing the value of the calculated
feature for that input data. Here's an example:

\begin{verbatim}
double feature1(float* a, float *b) {
  ...
  return foo;
}

...
wrap_feature<float*, float*> _feature1(feature1);
test_variant.add_input_feature(&_feature1);
\end{verbatim}

\subsubsection{Specifying Architectural Features}
Since architectural features are assumed to be constant during run-time,
they can be calculated once and added to the feature set of the variant
using the \texttt{add\_arch\_feature} function.

\subsection{Customizing the Autotuner}
\subsection{Providing Training and Test Data}
\subsection{Running the Autotuner}
\subsection{Using the Tuned Application}

\end{document}
